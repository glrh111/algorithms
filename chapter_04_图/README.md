+ 无向图
+ 有向图
+ 加权图
+ 加权有向图

## 4.1 无向图

图：图是由一组顶点和一组能够将两个顶点相连的边组成的。

一般使用 0 ~ V-1 来表示一张含有 V 个顶点的图中的各个顶点。v - w 表示连接v和w的边，等同于 w - v .

特殊的图：
+ 自环：一条连接一个顶点和其自身的边
+ 平行边：连接同一対顶点的两条边

### 4.1.1 术语表

+ 相邻：通过一条边相连的两个顶点，并且该连接依附于这两个顶点
+ 子图：一副图的所有边的一个子集（以及他们所依附的所有顶点）组成的图
+ 路径：由边顺序相连的一系列顶点
       + 简单路径：一条没有重复顶点的路径
       + 环：至少含有一条边且起点和终点相同的路径
       + 简单环：不含有重复顶点和边的环
       + 路径的长度：路径包含的边数
+ 连通：两个顶点之间存在一条连接双方的路径
+ 连通图：从任意一个顶点都存在一条路径到达另一个任意顶点。
+ 无环图：不包含环的图
+ 树：无环连通图
  + 森林：互不相连的树的集合
  + 连通图的生成树：含有图的所有定点，而且是一棵树
  + 生成树森林：所有连通子图的生成树的集合
+ 密度：已经连接的顶点対 占 可能被连接的顶点対的比例
  + 稀疏图：被连接的顶点対很少
  + 稠密图：只有少部分顶点対之间没有边连接
+ 二分图：能够将所有结点分为两部分的图。不明觉历。
  
![图的详解](http://o9hjg7h8u.bkt.clouddn.com/4.1.3%E5%9B%BE%E7%9A%84%E8%AF%A6%E8%A7%A3.png)

树的一些性质，当且仅当一幅含有V个顶点的图G满足以下5个条件之一时，它是一棵树：
+ G有V-1条边且不含有环
+ G有V-1条边且是连通的
+ G是连通的，但删除任意一条边就会不连通
+ G是无环图，但添加任意一条边都会产生一条环
+ G中的任意一对顶点之间，仅存在一条简单路径

### 4.1.2 表示无向图的数据类型

返回类型 | 方法 | 描述
---|---|---
| Graph(int V) | 创建一个含有V个顶点，但是不含有边的图
| Graph(input Input) | 从标准输入流中读入一副图
int | V() | 顶点数
int | E() | 边数
void | addEdge(int v, int w) | 向图中添加一条边 v-w
Iterable<Interger> | adj(int v) | 和v相邻的所有顶点
String | toString() | 对象的字符串表示

![Graph的构造函数](http://o9hjg7h8u.bkt.clouddn.com/4.1.8Graph%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0.png)

![最常用的图处理代码](http://o9hjg7h8u.bkt.clouddn.com/4.1.2%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%84%E5%9B%BE%E5%A4%84%E7%90%86%E4%BB%A3%E7%A0%81.png)

#### 4.1.2.1 图的几种表示方法

两个基本要求：
+ 必须为可能在应用中碰到的各种类型的图留出足够空间
+ 实例方法的实现一定要快

可以考虑的表示方法：
+ 邻接矩阵：V维bool矩阵，每个值表示 v-w 是否相连。图顶点多的时候，不能满足第一个条件。
+ 边的数组：每个元素表示相连的两个顶点。但是不能快速实现adj方法，不满足第二个条件。
+ 邻接表数组：以顶点为索引，元素是与该顶点相邻的所有顶点（使用这个）

#### 4.1.2.2 邻接表的数据结构

性能特点：
+ 使用的空间和V+E成正比
+ 添加一条边所需的时间为常数
+ 遍历顶点v的所有相邻顶点所需的时间和v的度数成正比（处理每个相邻顶点所需的时间为常数）

#### 4.1.2.3 图的处理算法的设计模式

将图的表示和实现分离开来。弄出来一个 Search 的新类。

图处理算法的API

返回值类型 | 方法名 | 描述
---|---|---
| Search(g Graph, s int) | 构造
bool | marked(int v) | s, v 是否连通
int | count() | 与 s 连通的顶点总数

### 4.1.3 深度优先搜索

DepthFirstSearch 标记已经搜索过的顶点

### 4.1.4 寻找路径

路径的API Paths

返回值 | 方法名 | 描述
---|---|---
| Paths(graph Graph, source int) | 在G中找出所有起点为 source 的路径
bool | hasPathTo(int v) | 是否存在从source到v的路径
iterable | pathTo(int v) | s 到 v 的路径

### 4.1.5 广度优先搜索

单点最短路径：广度优先搜索 BFS

![BFS_and_DFS](http://o9hjg7h8u.bkt.clouddn.com/4.1.19BFS_and_DFS.png)

### 4.1.6 连通分量

深度优先搜索

连通分量的API

返回值类型 | 方法名 | 描述
---|---|---
| CC(graph Graph) | 预处理构造函数
bool | connected(int v, int w) | v w 是否连通
int | count() | 连通分量数
int | id(v int) | v 所在的连通分量的标识符

 




