字符串几个性质：
+ 字符：字符串由一系列字符组成，字符的类型是char
+ 不可变性：
+ 索引：从字符串中取得某个特定的字符：常数级别
+ 长度：常数级别
+ 子字符串：提取特定的子字符串。常数级别
+ 字符串的连接：将一个字符串追加到另一个字符串的末尾并创建一个新字符串。时间为平方级别
+ 字符数组：字符串的更底层表示

Java的两种字符串表示

操作 | 字符数组 | Java字符串
---|---|---
声明 | Char[] a | String s
根据索引访问数组 | a[i] | s.charAt(i)
获取字符串长度 | a.length | s.length()
表示方法转换 | a=s.toCharArray() | s=new String(a)

字母表的API Alphabet

返回类型 | 方法名 | 描述
---|---|---
- | Alphabet(s) | 根据 s 中的字符，创建一张新的字母表
char | toChar(int index) | 索引index处的char表示
int | toIndex(char c) | 获取c的索引，[0, R-1]
bool | contains(char c) | c在字母表中吗
int | R() | 基数，字母表中的字符数量
int | lgR() | 表示一个索引所需的位数 不明觉历。二进制位数吗
int[] | toIndices(string s) | 将s转换为R进制的整数. 类似golang中的 []rune
string | toChars(int[] indices) | 将R进制的整数，转换为基于该字母表的字符串

标准字母表列表
名称 | R() | lgR() | 字符集
---|---|---
BINARY | 2 | 1 | `01`
DNA | 4 | 2 | `ACTG`
OCTAL | 8 | 3 | `01234567`
DECIMAL | 10 | 4 | `0123456789`
HEXADECIMAL | 16 | 4 | `0123456789ABCDEF`
PROTEIN(蛋白质) | 20 | 5 | -
LOWERCASE | 26 | 5 | -
UPPERCASE | 26 | 5 | -
BASE64 | 64 | 6 | 26 + 26 + 10 + '+/'
ASCII | 128 | 7 | ASCII字符集
EXTENDED ASCII | 258 | 8 | 扩展的ASCII
UNICODE16 | 65536 | 16 | Unicode 字符集

## 5.1 字符串排序

+ 低位优先排序 LSD：从右到左检查字符。适合键的长度都相同的字符串应用。
+ 高位优先排序 MSD：从左到右检查字符。类似快速排序，递归实现。

### 5.1.1 键索引计数法

适用于小整数键. 给每个元素分配一个组号 key，范围在 [0, R-1]

#### 5.1.1.1 频率统计

统计 key 出现的频率，对于数组的每个元素， count[key+1]++

#### 5.1.1.2 将频率转换为索引

使用count[] 来计算每个键在排序结果中的起始索引位置。
在这个例子中，因为第一组中有三个人，第二组中有5个人，因此第三组中的同学在排序结果中的起始位置为8。
一般来说，任意给定的键的起始索引，均为所有较小的键所对应的出现频率之和。

#### 5.1.1.3 数据分类 

在将count[] 数组转化为一张索引表之后，将所有元素移动到一个辅助数组aux[] 中以进行排序。
每个元素在aux[] 中的位置是由它的键（组别）对应的count[] 中的值决定的，在移动之后，将count[] 中对应的元素值+1, 
以保证 count[r] 总是下一个键为r 的元素在aux[] 中的索引位置。
这个过程只需遍历一遍数据即可产生排序结果。键相同的元素在排序后会被聚集在一起，蛋相对顺序没有变化。

#### 5.1.1.4 回写

aux[] 数组中，已经完成排序，这一步将结果复制到原数组。

### 5.1.2 低位优先的字符串排序 LSD

如果字符串宽度为 W，那么需要进行 W次键索引排序法，字符串即为有序。从右向左。每次使用最左边的字符作为键。

命题：低位优先的字符串排序算法，能够稳定地将定长字符串排序。

时间复杂度：与 WN 成正比。空间复杂度：N+R 成正比

### 5.1.3 高位优先的字符串排序 MSD

更通用的字符串排序算法（字符串长度不同）, 与低位排序相比，只需要特殊处理字符串结束时的情况。

指定的字母表。高位优先排序的成本与字母表中的字符数量关系比较大，所以，可以指定排序的字母表。

数据count[] 数组在 [0, R+1] 时候的意义：

count[r] 

与低位优先排序的不同：
+ 如果字符串结束，那么返回索引为 -1
+ count[r] 中的r值，等同于低位优先中的 r+1. 这么一来，不需要在本次排序的，都归入一类，放在最前面了。
+ 范围递归排序
+ 切分的小数组排序，需要切换到插入排序，以提高性能。

![切换阈值](http://o9hjg7h8u.bkt.clouddn.com/5.1.13%E5%88%87%E6%8D%A2%E9%98%88%E5%80%BC.png)

性能：
+ 随机输入：只会检查足以区别字符串所需的字符，运行时间是亚线性
+ 非随机输入：对于等值键，有处理陷阱
+ 最坏情况下：检查键中的所有字符，线性时间（和低位优先相同）

### 5.1.4 三向字符串快速排序

改进版的高位优先算法：能够更好处理等值键、有较长公共前缀的键、取值范围较小的键和小数组、不需要额外空间

### 5.1.5 字符串排序算法的选择

![排序算法比较](http://o9hjg7h8u.bkt.clouddn.com/5.1.2%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%AF%94%E8%BE%83.png)


## 5.2 单词查找树

本节算法的要求是：
+ 查找命中所需的时间，与被查找的键的长度成正比
+ 查找未命中，只需检查若干个字符

![单词查找树](http://o9hjg7h8u.bkt.clouddn.com/5.2.1%E5%8D%95%E8%AF%8D%E6%9F%A5%E6%89%BE%E6%A0%91.png)

参数 R 代表单词查找树基于R个字母组成的alphabeta。R向单词查找树。



























