字符串几个性质：
+ 字符：字符串由一系列字符组成，字符的类型是char
+ 不可变性：
+ 索引：从字符串中取得某个特定的字符：常数级别
+ 长度：常数级别
+ 子字符串：提取特定的子字符串。常数级别
+ 字符串的连接：将一个字符串追加到另一个字符串的末尾并创建一个新字符串。时间为平方级别
+ 字符数组：字符串的更底层表示

Java的两种字符串表示

操作 | 字符数组 | Java字符串
---|---|---
声明 | Char[] a | String s
根据索引访问数组 | a[i] | s.charAt(i)
获取字符串长度 | a.length | s.length()
表示方法转换 | a=s.toCharArray() | s=new String(a)

字母表的API Alphabet

返回类型 | 方法名 | 描述
---|---|---
- | Alphabet(s) | 根据 s 中的字符，创建一张新的字母表
char | toChar(int index) | 索引index处的char表示
int | toIndex(char c) | 获取c的索引，[0, R-1]
bool | contains(char c) | c在字母表中吗
int | R() | 基数，字母表中的字符数量
int | lgR() | 表示一个索引所需的位数 不明觉历。二进制位数吗
int[] | toIndices(string s) | 将s转换为R进制的整数. 
string | toChars(int[] indices) | 将R进制的整数，转换为基于该字母表的字符串

标准字母表列表
名称 | R() | lgR() | 字符集
---|---|---
BINARY | 2 | 1 | `01`
DNA | 4 | 2 | `ACTG`
OCTAL | 8 | 3 | `01234567`
DECIMAL | 10 | 4 | `0123456789`
HEXADECIMAL | 16 | 4 | `0123456789ABCDEF`
PROTEIN(蛋白质) | 20 | 5 | -
LOWERCASE | 26 | 5 | -
UPPERCASE | 26 | 5 | -
BASE64 | 64 | 6 | 26 + 26 + 10 + '+/'
ASCII | 128 | 7 | ASCII字符集
EXTENDED ASCII | 258 | 8 | 扩展的ASCII
UNICODE16 | 65536 | 16 | Unicode 字符集

## 5.1 字符串排序

+ 低位优先排序 LSD：从右到左检查字符。适合键的长度都相同的字符串应用。
+ 高位优先排序 MSD：从左到右检查字符。类似快速排序，递归实现。

### 5.1.1 键索引计数法

适用于小整数键. 给每个元素分配一个组号 key，范围在 [0, R-1]

#### 5.1.1.1 频率统计

统计 key 出现的频率，对于数组的每个元素， count[key+1]++

#### 5.1.1.2 将频率转换为索引

使用count[] 来计算每个键在排序结果中的起始索引位置。
在这个例子中，因为第一组中有三个人，第二组中有5个人，因此第三组中的同学在排序结果中的起始位置为8。
一般来说，任意给定的键的起始索引，均为所有较小的键所对应的出现频率之和。

#### 5.1.1.3 数据分类 

在将count[] 数组转化为一张索引表之后，将所有元素移动到一个辅助数组aux[] 中以进行排序。
每个元素在aux[] 中的位置是由它的键（组别）对应的count[] 中的值决定的，在移动之后，将count[] 中对应的元素值+1, 
以保证 count[r] 总是下一个键为r 的元素在aux[] 中的索引位置。
这个过程只需遍历一遍数据即可产生排序结果。键相同的元素在排序后会被聚集在一起，蛋相对顺序没有变化。

#### 5.1.1.4 回写

aux[] 数组中，已经完成排序，这一步将结果复制到原数组。

### 5.1.2 低位优先的字符串排序 LSD

如果字符串宽度为 W，那么需要进行 W次键索引排序法，字符串即为有序。从右向左。每次使用最左边的字符作为键。

命题：低位优先的字符串排序算法，能够稳定地将定长字符串排序。

时间复杂度：与 WN 成正比。空间复杂度：N+R 成正比

### 5.1.3 高位优先的字符串排序 MSD

更通用的字符串排序算法（字符串长度不同）, 与低位排序相比，只需要特殊处理字符串结束时的情况。

指定的字母表。高位优先排序的成本与字母表中的字符数量关系比较大，所以，可以指定排序的字母表。

数据count[] 数组在 [0, R+1] 时候的意义：

count[r] 

与低位优先排序的不同：
+ 如果字符串结束，那么返回索引为 -1
+ count[r] 中的r值，等同于低位优先中的 r+1. 这么一来，不需要在本次排序的，都归入一类，放在最前面了。
+ 范围递归排序
+ 切分的小数组排序，需要切换到插入排序，以提高性能。

![切换阈值](http://o9hjg7h8u.bkt.clouddn.com/5.1.13%E5%88%87%E6%8D%A2%E9%98%88%E5%80%BC.png)

性能：
+ 随机输入：只会检查足以区别字符串所需的字符，运行时间是亚线性
+ 非随机输入：对于等值键，有处理陷阱
+ 最坏情况下：检查键中的所有字符，线性时间（和低位优先相同）

### 5.1.4 三向字符串快速排序

改进版的高位优先算法：能够更好处理等值键、有较长公共前缀的键、取值范围较小的键和小数组、不需要额外空间

### 5.1.5 字符串排序算法的选择

![排序算法比较](http://o9hjg7h8u.bkt.clouddn.com/5.1.2%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%AF%94%E8%BE%83.png)


## 5.2 单词查找树

本节算法的要求是：
+ 查找命中所需的时间，与被查找的键的长度成正比
+ 查找未命中，只需检查若干个字符

![单词查找树](http://o9hjg7h8u.bkt.clouddn.com/5.2.1%E5%8D%95%E8%AF%8D%E6%9F%A5%E6%89%BE%E6%A0%91.png)

参数 R 代表单词查找树基于R个字母组成的alphabeta。R向单词查找树。

### 5.2.3 三向单词查找树

避免R向单词查找树过度的空间消耗

每个结点含有
+ 一个字符
+ 三条链接
+ 一个值

![字符串查找算法的性能特点](http://o9hjg7h8u.bkt.clouddn.com/5.2.3%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E7%89%B9%E7%82%B9.png)


## 5.3 子字符串查找

长度为N的文本s，和长度为M的模式p，在文本中找到和该模式相符的子字符串。实例如下：
+ 在编辑器中查找文本
+ 在截获的通信内容中，寻找某种模式

Knuth-Morris-Pratt算法 和 Boyer-Moore算法，需要対字符串进行复杂的预处理。

M.O.Rabin和R.M.Karp使用散列开发出了一种与暴力算法几乎一样简单，但运行时间与M+N成正比的概率极高的算法。

### 5.3.2 暴力子字符串查找算法

两个循环。时间复杂度为 N * M

### 5.3.3 Knuth-Morris-Pratt子字符串查找算法 

确定有限状态自动机

### 5.3.4 Boyer-Moore 字符串查找算法

启发式地处理不匹配的字符串

### 5.3.5 Rabin-Karp 指纹字符串查找算法xs

计算模式的散列值，然后计算字符串中长度为M的子串可能的散列值，如果两者可以对上，那么再深入比较。

关键是怎么计算子串的hash值。使用Honer方法。

![关键思想](http://o9hjg7h8u.bkt.clouddn.com/5.3.16%E5%85%B3%E9%94%AE%E6%80%9D%E6%83%B3.png)

可以推倒出来：
 
x(i+1) = R * (x(i) - t(i) * R^(M-1)) + t(M+i)

h(i) = x(i) / Q 

其中Q为一个大素数，R为字母表长度，M为patt长度s, t(i)为在s中位置i的字符在字母表中的索引

h(i+1) = ((h(i) + t(i) * (Q - R^(M-1))) * R + t(i+M)) % Q

## 5.4 正则表达式

### 5.4.1 使用正则表达式描述模式

由三种基本操作，和作为操作数的字符组成。用语言指代一个字符串的集合（可能是无限的），用模式指代一种语言的详细说明。

#### 5.4.1.1 连接操作

AB 指定了语言{AB} 由A和B连接而成 

#### 5.4.1.2 或操作

A|B 指定了语言 {A,B}, 连接操作的优先级高于或操作

#### 5.4.1.3 闭包操作

将模式的部分重复任意次数。优先级高于连接。

AB*

#### 5.4.1.4 括号

改变默认的优先级顺序

正则表达式的定义：一个正则表达式可以是（语法）
+ 空字符串 ∈
+ 单个字符
+ 包含在括号中的另一个正则表达式
+ 两个或多个连接起来的正则表达式
+ 由或运算符分隔的两个或多个正则表达式
+ 由闭包运算符标记的一个正则表达式

每个正则表达式表示的都是一个字符串的集合，定义如下（语义）：
+ 空正则表达式表示的字符串的集合为空，含有0个元素
+ 一个字符表示的字符串的集合含有一个元素，即该字符本身
+ 一个由括号和包含在其中的正则表达式组成的正则表达式表示的字符串的集合与括号内的正则表达式相同
+ 由两个正则表达式连接起来的正则表达式表示的字符串的集合，为这两个正则表达式分别表示的字符串集合的叉乘，
+ 由或运算符连接的两个正则表达式所表示的字符串的集合为两个正则表达式所分别表示的字符串集合的并集
+ 由一个正则表达式闭包所表示的字符串的集合由∈或将被修饰的正则表达式所表示的字符串集合重复任意次所得到的所有字符串所组成。

### 5.4.2 缩略写法

#### 5.4.2.1 字符集描述

名称 | 记法 | 举例
---|---|---
通配符 | . |A.B
指定的集合 | 包含在 [] 中的字符 | [AEIOU]*
范围集合 | 包含在 [] 中，由 "-" 分隔 | [A-Z][0-9]
补集 | 包含在 [] 中，首字母为 ^ | [^AEIOU]*

#### 5.4.2.2 闭包的简写

闭包将它的操作数复制任意多次。

选项 | 记法 | 举例 | 原始写法 | 语言中的字符串 | 不在语言中的字符串
---|---|---|---|---|---
至少重复1次 | + | (AB)+ | (AB)(AB)* | AB ABABAB | ∈ BA
重复0或1次 | ? | (AB)? | ∈&#124;AB | ∈|AB | 所有其他字符串
重复指定次数 | 由 {} 指定次数 | (AB){3} | (AB)(AB)(AB) | ABABAB | 所有其他
重复指定范围的次数 | 由 {} 指定范围 | (AB){1-3} | (AB)&#124;(AB)(AB) | AB ABAB | 所有其他

#### 5.4.2.3 转义序列

+ 构造正则表达式的元字符： \ . | * ( )
+ 特殊字符，空白字符 \t \n

都使用 \ 进行转义

### 5.4.3 正则表达式的实际应用

#### 5.4.3.1 子字符串查找

#### 5.4.3.2 合法性检查

#### 5.4.3.3 程序员的工具箱

grep 

#### 5.4.3.4 基因组

#### 5.4.3.5 搜索

互联网搜索引擎

#### 5.4.3.6 正则表达式的可能性

(0 | 1(01*0)*1)* 描述的数字，都可以被3整除

#### 5.4.3.7 局限

正则无法描述所有语言。

+ 无法描述所有合法的正则
+ 检查括号是否匹配完整
+ 检查字符串中的A B是否一样多

### 5.4.4 非确定有限状态自动机 NFA

kleene定理，对于任意正则表达式都存在一个与之对应的非确定有限状态自动机（反之亦然）。

### 5.4.5 模拟 NFA 的运行

![NFA示例](http://o9hjg7h8u.bkt.clouddn.com/5.4.1%E7%A4%BA%E4%BE%8BNFA.png)

#### 5.4.5.1 自动机的表示

正则表达式本身给出了所有状态名，[0, M], M 为正则表达式的长度。用char数组[]re 表示正则表达式本身，
这个数组也表示了匹配的转换，如果re[i]存在于字母表中，那么就存在从i到i+1的匹配转换。

∈ 转换，用有向图表示，他们都是连接0 ~ M 之间的各个顶点之间的有向边（红色的边）。

#### 5.4.5.2 NFA的模拟与可达性

为了模拟NFA的运行轨迹，我们会记录自动机在检查当前输入字符时可能遇到的所有状态的集合，关键的计算是多点可达性问题。

查找从状态0通过 ∈转换可达的状态来初始化这个集合。对于集合中的每个状态，检查它是否可能与第一个输入字符相匹配。

检查并匹配之后，就得到了NFA在匹配第一个字符之后可能到达的状态的集合。

## 5.5 数据压缩

压缩数据的主要原因：
+ 节省保存信息所需的空间
+ 节省传输信息所需的时间

### 5.5.1 规则

计算机处理的所有数据，最终都要转化为比特流，即比特的序列。比特 = 位。

字节流：可以看作固定大小的字节序列的比特序列。

+ 压缩：将比特流B转化为压缩后的版本 C(B)
+ 展开：将C(B)转化为B

压缩的目标是，C(B)/B 压缩率 的最小化。

这个模型也称为无损压缩模型。

### 5.5.2 读写二进制数据

抽象用来处理比特流的两份API：BinaryStdIn , BinaryStdOut

#### 5.5.2.1 二进制的输入输出

今天大多数输入输出系统，都基于8位字节流。所以应该允许读取单个bit，或者原始类型的数据（定宽bit）

返回类型 | BinaryStdIn | 描述
---|---|---
boolean | readBoolean() | 读取1位数据并返回一个bool值
char | readChar() | 读取8位数据，并返回char值
char | readChar(r int) | 读取r位[1,16]数据，并返回一个char值？存疑。为毛只返回8位
boolean | isEmpty() | 比特流是否为空
void | close() | 关闭比特流

返回类型 | BinaryStdOut | 描述
---|---|---
void | write(bool b) | 写入指定的比特
void | writeChar(char c) | 写入指定的8个bit
void | write(char c, int r) | 写入字符c的低r位[0,16]
void | close() | 关闭比特流

close需要保证，关闭之前，所有write方法的数据都写入了比特流。比特流的最后一个字节必须用0补齐，以保证和文件系统的兼容性。  

![日期表示示例](http://o9hjg7h8u.bkt.clouddn.com/5.5.2%E6%97%A5%E6%9C%9F%E8%A1%A8%E7%A4%BA%E7%A4%BA%E4%BE%8B.png)

#### 5.5.2.3 二进制转储

调试的时候如何检查比特流的内容呢？只有检查每一个bit。

dump 转储，表示比特流的一种可供人类阅读的形势。以下是三个相关的工具：
+ BinaryDump 将01打印出来
+ HexDump 将数据组织成8位的字节，并表示为2位的十六进制
+ PictureDump 白色像素表示0,黑色像素表示1

#### 5.5.2.4 ASCII 编码

可以将字节流表示为ASCII字符打印出来，更便于阅读了。

![ASCII](http://o9hjg7h8u.bkt.clouddn.com/5.5.4ASCII.png)

### 5.5.3 局限

#### 5.5.3.1 通用数据压缩

通用性的数据压缩不可能存在。
+ 如果可能，那么它可以迭代压缩自身，直到长度为 0
+ 对于无损压缩，任意压缩后的数据肯定不能代表压缩前的。可能性推导。

#### 5.5.3.2 不可判断性

很多数据由程序生成，所以找出创造这个文件的程序，然后运行，也算是一种压缩。比如视频文件、书等。

可以证明：最优数据压缩是一个不可判定的问题。

所以需要尽量利用被压缩数据流的已知结构。我们使用下面的用例
+ 小规模的字母表
+ 较长的连续相同的位或字符
+ 频繁使用的字符
+ 较长的连续重复的位或字符

### 5.5.4 基因组

#### 5.5.4.1 基因数据

### 5.5.5 游程编码

最简单的冗余形势，一长串重复的bit。Run-Length Encoding

### 5.5.6 霍夫曼压缩

能够大幅压缩自然语言文件空间。原理是，放弃普通文本文件的保存方式，不再使用7,8bit表示一个字符，而是用较少的bit保存出现频率高的字符，
用较多的bit保存出现频率低的字符。

#### 5.5.6.1 变长前缀码

将每个字符，使用bit字符串表示，后者不必具有相同的长度。

如果不需要分隔符，即所有字符的bit串形式都不会作为其他字符的前缀，那么含有这种性质的编码叫做前缀码。

#### 5.5.6.2 前缀码的单词查找树

![前缀码与单词查找树](http://o9hjg7h8u.bkt.clouddn.com/5.5.10%E5%89%8D%E7%BC%80%E7%A0%81%E4%B8%8E%E5%8D%95%E8%AF%8D%E6%9F%A5%E6%89%BE%E6%A0%91.png)

可以用单词查找树表示前缀码。如何才能找到压缩率最高的前缀码？通用方法由D.Huffman发现，称为霍夫曼编码。

#### 5.5.6.3 概述

使用前缀码进行数据压缩需要5个步骤：
+ 构造一棵编码单词查找树
+ 将该树以字节流的形式写入输出以便展开时使用
+ 使用该树，将字节流编码为bit流

展开时需要：
+ 读取单词查找树
+ 使用该树将bit流编码

#### 5.5.6.4 单词查找树的结点

+ left, right  分别对应 0, 1
+ freq 出现频率
+ ch 编码的字符

#### 5.5.6.6 使用前缀码压缩

buildCode() 方法： 单词查找树  ->  编译码

#### 5.5.6.7 单词查找树的构造

![构造霍夫曼单词查找树](http://o9hjg7h8u.bkt.clouddn.com/5.5.12%E6%9E%84%E9%80%A0%E9%9C%8D%E5%A4%AB%E6%9B%BC%E5%8D%95%E8%AF%8D%E6%9F%A5%E6%89%BE%E6%A0%91.png)

需要读取两遍文件，第一遍统计出现频率，构造树; 第二遍执行压缩。

压缩的时候，也需要树的信息。







































