## 2.1 初级排序

### 2.1.2 选择排序

外循环N次，每次都找到最小的元素，与子数组第一个元素比较。时间复杂度 N^2/2 比较 N 次交换

挺像冒泡排序：每两个元素比较，并in place 交换，将大的元素交换到最后。循环N次，数组变为有序。时间复杂度 N^2/2 比较 N^2/4 次交换(大概为比较次数的一半)？

## 2.3 快速排序

应用最广泛的排序算法。
+ 实现简单
+ 适用于各种不同的输入数据
+ 在一般应用中比其他排序算法快得多
+ 时间复杂度 NlgN


缺点是：
+ 比较脆弱，必须非常小心才能避免低劣的性能

### 快速排序的改进

#### 切换到插入排序

+ 对于小数组，插入排序比快速排序快
+ 因为递归，小数组也会自己调用自己

if (hi <= lo + M) { Inserction.sort(data, lo, hi); return; }

M 需要根据实际考量，一般取值为 [5, 15]

#### 三取样切分

取数组中一小部分元素的中位数median来计算切分元素。

还可以将取样元素放在数组末尾作为哨兵来去掉partition中的边界测试

#### 熵最优的排序

对于含有大量重复元素的列表，快速排序会将重复元素也排序，但是并不需要这样。

Dijkstra发明了三向切分快速排序

![三向切分](http://o9hjg7h8u.bkt.clouddn.com/2.3.4%E4%B8%89%E5%90%91%E5%88%87%E5%88%86%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.png)

实现了，发现快的一笔。

## 2.4 优先队列

动态排序。每次给定一部分元素进行排序。

删除最大元素和插入元素

API如下

返回类型 | 方法名称 | 描述
---|---|---
- | MaxPQ() | 构造函数
- | MaxPQ(max int) | 有最大容量的
- | MaxPQ([]key a) | 带有初始化元素的
void | insert(a key) | 插入元素
key | max() | 返回最大元素
key | delMax() | 删除并返回最大元素
bool | isEmpty() | PQ是否为空
int | size() | 元素个数

MinPQ 的API与之类似。

实际应用：从N个整数中，选出M个最大的。

### 2.4.2 初级实现

可以使用数组，链表（可以使有序或无序的，区别在于 insert 和 delete 中的一个开销比较大）

坏处是，insert delete中的一个，最坏情况下需要线性时间完成。

下面是实现比较

数据结构 | 插入元素 | 删除最大元素
---|---|---
有序数组 | N | 1
无序数组 | 1 | N
堆 | logN | logN
理想情况 | 1 | 1

### 2.4.3 堆的定义

二叉堆

当一棵二叉树的每个结点，都大于等于它的两个子结点时，称为堆有序。

用完全二叉树表示二叉堆，进一步可以用数组表示。将二叉树的结点，按照层级放入数组中。

![堆的表示](http://o9hjg7h8u.bkt.clouddn.com/2.3.2%E5%A0%86%E7%9A%84%E8%A1%A8%E7%A4%BA.png)

### 2.4.4 堆的算法

#### 2.4.4.1 从下到上的堆的有序化（上浮） swim

当一个结点，比它的父结点大，可以通过swim交换

#### 2.4.4.2 从上到下的堆的有序化（下沉） sink

![swim and sink](http://o9hjg7h8u.bkt.clouddn.com/2.4.4swim_and_sink.png)

+ 插入元素：将元素插入到数组末尾，增加堆的大小，并swim到合适位置
+ 删除最大元素：从数组顶端删除最大元素，将最后一个元素放到顶端，减小堆的大小，并sink到合适的位置

![堆的操作](http://o9hjg7h8u.bkt.clouddn.com/2.4.5%E5%A0%86%E7%9A%84%E6%93%8D%E4%BD%9C.png)

#### 2.4.4.3 多叉堆 heap

可以将二叉堆拓展为任意 d叉堆，其中delMax 操作有区别：每次子结点之间需要相互比较，找出最大的，与父结点比较。

#### 2.4.4.4 调整数组大小

不必每次 del 或者 insert 的时候都调整数组大小，而在必要的时候，将数组加倍或者减半。

#### 2.4.4.5 元素的不可变性

队列元素的大小用于比较，改变他们会破坏堆的有序性。

#### 2.4.4.6 索引优先队列

索引优先队列 TODO 为毛看不懂这里说的是啥？

### 2.4.5 堆排序

![堆排序](http://o9hjg7h8u.bkt.clouddn.com/2.4.7%E5%A0%86%E6%8E%92%E5%BA%8F.png)

分为构造阶段和sink排序阶段
+ 构造阶段：构造一个有序的堆。数组从右向左，从倒数第二层开始扫描
+ sink排序：每次交换首个元素和最后一个元素，然后将首个元素sink，这样每次排定一个最大的元素到末尾。









