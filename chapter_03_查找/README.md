## 3.1 符号表

符号表：一张抽象的表格，我们会将信息存储在其中，然后按照指定的键来搜索并获取这些信息。有时称为字典，有时称为索引。

三种实现高效符号表的经典类型：二叉查找树，红黑树，散列表。

典型的符号表应用

应用|查找的目的|键|值
---|---|---|---
字典|找出单词的释义|单词|释义
图书索引|找出相关的页码|术语|一串页码
文件共享|找出歌曲的下载地址|歌曲名|url之类的
账户管理|处理交易|账户号码|交易详情
网络搜索|找出相关网页|关键字|网页名称
编译器|找出符号的类型和值|变量名|类型和值

### 3.1.1 API

符号表API

返回类型 | 方法名 | desc
---|---|---
 | ST()创建一张符号表 |
void | put(Key key, Value value) | 存入键值对
Value | get(Key key) | 获取键key对应的值
void | delete(Key key) | 删除键值对
boolean | contains(Key key) | 键key在表中是否有对应的值  get(key) != nul
boolean | isEmpty() | 表是否为空  size() == 0
int | size() | 键值对数量
Iterable<Key> | keys() | 所有键的集合

为了保持代码的一致、简洁和实用，以下是几个设计决策
+ 范型
+ 重复的键
  + 每个键只对应一个值
  + 新存入的键值対和表中已有的冲突时，新值会替换旧值
+ 空键null 键不能位null
+ 空值null 值不能有null
  + 键不存在时可以返回null
  + 导致可以使用 get() 的返回值判断键是否存在
  + 导致可以将值设置为 null(put) 来实现删除 
+ 删除操作
  + 延时删除 将键对应的值置为空，然后在某个时候删除所有值为空的键 put(key, null) 是一种实现
  + 即时删除 立刻从表中删除指定的键 delete(key) 是这种实现
+ 便捷方法 ：用已经实现的方法实现
+ 迭代 使用keys返回包含所有键的迭代器
+ 键的等价性 怎么判断键是否存在的等价

### 3.1.2 有序符号表

在典型应用中，键都是Comparable对象，许多符号表的实现，都利用Comparable带来的键的有序性，更好得实现put get方法。

以下是有序的泛型符号表API

返回值类型 | 方法名 | 说明
---|---|---
| ST() | 创建一张有序符号表
void | put(Key key, Value value) | 将键值対存入表中
Value | get(Key key) | 获取键key对应的值
void | delete(Key key) | 从表中删除键key
boolean | contains(Key key) | 表中是否有某个键
boolean | isEmpty() | 表是否为空
int | size() | 表中键值対数量
Key | min() | 最小的键
Key | max() | 最大的键
Key | floor(Key key) | 小于等于key的最大键
Key | ceiling(Key key) | 大于等于key的最小键
int | rank(Key key) | 小于key的键的数量
Key | select(int k) | 排名为k的键
void | deleteMin() | 删除最小的键 delete(min())
void | deleteMax() | 删除最大的键 delete(max())
int | size(Key lo, Key hi) | \[lo..hi\] 之间键的数量 
Iterable<Key> | keys(Key lo, Key hi) | \[lo..hi\]之间的所有键 
Iterable<Key> | keys() | 表中的所有键的集合，已排序 keys(min(), max())

#### 3.1.2.1 最大键和最小键

#### 3.1.2.2 向下取整和向上取整

floor ceiling

#### 3.1.2.3 排名和选择

+ 0 ~ size()-1 的所有i满足： i == rank(select(i))
+ 所有key都满足: key == select(rank(key))

挑战是，实现插入删除查找的同时，快速实现这两种操作。

#### 3.1.2.4 范围查找

size(), keys() 能够接受两个参数。

能够处理这类查询，是有序符号表在实践中被广泛应用的重要原因。

#### 3.1.2.5 例外情况

如果一个方法需要返回一个键但表中没有合适的键返回时，约定抛出一个异常。

符号表为空时，min(), max(), deleteMin(), deleteMax(), floor(), ceiling() 都会抛出异常。

k < 0, 或者 k >= size() 时，select(k) 也会抛出异常。

#### 3.1.2.6 便捷方法

#### 3.1.2.7 键的等价性

#### 3.1.2.8 成本模型

### 3.1.3 用例举例

#### 3.1.3.1 行为测试用例 

用一串字符串与各自对应的索引，来作为key value。

#### 3.1.3.2 性能测试用例

使用网上知名测试内容，进行单词统计。符号表运用共性：
+ 混合使用插入和查找的操作
+ 大量的不同键
+ 查找操作比插入操作多得多
+ 查找和插入操作并非随机

### 3.1.4 无序链表中的顺序查找

### 3.1.5 有序数组中的二分查找

+ 使用一対平行的数组，一个存储key，另一个存储value
+ 需要保证存储key数组有序
+ 实现核心是 rank() 方法，它返回小于给定键的元素的数量
+ get() put() 都借助与 rank()

put() 时间复杂度是对数级别，还是太慢了，依然无法支撑大型问题。

![3.1.9BinarySearchST操作成本.png](http://o9hjg7h8u.bkt.clouddn.com/3.1.9BinarySearchST%E6%93%8D%E4%BD%9C%E6%88%90%E6%9C%AC.png)

![符号表的各种实现的优缺点](http://o9hjg7h8u.bkt.clouddn.com/3.1.11%E7%AC%A6%E5%8F%B7%E8%A1%A8%E7%9A%84%E5%90%84%E7%A7%8D%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9.png)

## 3.2 二叉查找树 BST

能够将链表插入的灵活性，与有序数组查找的高效性相结合的符号表实现。

+ 结点指向的链接可以指向空或者其他结点
+ 每个结点只能有一个父节点指向自己（根结点没有父结点）
+ 每个结点只有左右两个链接，指向左子结点和右子节点
+ 每个结点都可以看作是一个二叉树

二叉树可以定义为一个空链接，或者一个有左右两个链接的结点，每个链接都指向一棵独立的二叉树。

![详解二叉树](http://o9hjg7h8u.bkt.clouddn.com/3.2.1%E8%AF%A6%E8%A7%A3%E4%BA%8C%E5%8F%89%E6%A0%91.png)

![详解二叉查找树](http://o9hjg7h8u.bkt.clouddn.com/3.2.2%E8%AF%A6%E8%A7%A3%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91.png)

### 3.2.1 基本实现

#### 3.2.1.1 数据表示

每个结点含有如下的结构：
+ 一个键
+ 一个值
+ 一条左链接：里边的键小于该结点
+ 一条右链接：里边的键大于该结点
+ 一个结点计数器：size(x) = size(x.left) + size(x.right) + 1

#### 3.2.1.2 查找

### 3.2.2 分析

二叉查找树和快速排序的相似性

查找命中平均需要的次数： 2lnN 约等于 1.39lgN. 比二分查找高 39%
 
插入操作和查找未命中平均所需比较次数 2lnN ~ 1.39lgN

![实验二叉树比较次数](http://o9hjg7h8u.bkt.clouddn.com/3.2.1%E5%AE%9E%E9%AA%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E6%AF%94%E8%BE%83%E6%AC%A1%E6%95%B0.png)

### 3.2.3 有序性相关的方法和删除操作

![删除操作](http://o9hjg7h8u.bkt.clouddn.com/3.2.13%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C.png)

## 3.3 平衡查找树

保持二分查找树的平衡性。因为普通的二叉树在最坏情况下的性能很糟糕。

### 3.3.1 2-3查找树

一棵2-3查找树，或为一棵空树，或由以下结点组成：
+ 2-结点：含有1个键和两条链接
  + 左链接指向的2-3树中的键都小于该结点
  + 右链接指向的2-3树中的键都大于该结点
+ 2-结点：含有2个键和三条链接
  + 左链接指向的2-3树中的键都小于该结点
  + 中链接指向的2-3树中的键位于两个键中间
  + 右链接指向的2-3树中的键都大于该结点

指向空树的链接称为空链接。

![2-3查找树示意图](http://o9hjg7h8u.bkt.clouddn.com/3.3.1.2-3%E6%9F%A5%E6%89%BE%E6%A0%91%E7%A4%BA%E6%84%8F%E5%9B%BE.png)

### 3.3.2 红黑二叉查找树

将3结点做特殊替换。

红黑树的定义
+ 红链接均为左链接
+ 没有任何一个结点同时和两条红链接相连接
+ 该树是完美黑色平衡，即任意空链接到跟结点的路径上的黑链接数量相等

红黑树既是2-3树，又是二叉树，结合了他们的优点：
+ 二叉查找树中简洁高效的查找方法
+ 2-3树中高效的平衡插入算法

![红黑树](http://o9hjg7h8u.bkt.clouddn.com/3.3.13%E7%BA%A2%E9%BB%91%E6%A0%91.png)

![红黑树颜色定义](http://o9hjg7h8u.bkt.clouddn.com/3.3.14%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E9%A2%9C%E8%89%B2.png)

+ 红黑树Node 的颜色属性：父节点指向它的链接的颜色
+ 空链接为黑链接

#### 3.3.2.1 旋转

![旋转](http://o9hjg7h8u.bkt.clouddn.com/3.3.16%E6%97%8B%E8%BD%AC.png)

今天先不看，头晕。

## 3.4 散列表

查找算法分为两步:
+ 用散列函数将被查找的键转化为数组的一个索引。多个键可能被转化为一个索引
+ 处理碰撞冲突：拉链法，线性探测法

权衡空间和时间

散列表的缺点：
+ 每种类型的键都需要一个优秀的散列函数
+ 性能保证来自于散列函数的质量
+ 散列函数的计算可能复杂而且昂贵
+ 难以支持有序性有关的符号表操作

### 3.4.1 散列函数

将键，转化为数组的索引。如果数组可以容纳M个元素，那么我们需要一个将任意键转化为数组范围内的索引[0, M-1]
+ 易于计算
+ 分布均匀

简单例子：
+ 正整数：除留余数法 k % M , M为素数更好
+ 浮点树：转化为二进制，然后使用除留余数法
+ 字符串：将字符串，化为大整数
+ 组合键：int hash  = (((day * R + month) % M ) * R + year ) % M

可以为每一个数据类型，实现一个 hashCode() 方法，来返回一个hash值。

软缓存：如果计算hash值比较费功夫，那么将key的hash值保存起来。

### 3.4.2 基于拉链法的散列表

SeparateChainingHashST 可以使用之前实现的ST来作为每个数组的值。

用M个ST来表示N个键，每个ST的size是 N/M。

基于拉链法的效率提升：
+ 比原数据结构的查找和插入效率提升M倍

有序性相关怎么操作？无法进行有序性操作。

如何保证作为数组元素的列表，拥有较短的长度？动态调整数组大小。

### 3.4.3 基于线性探测法的散列表

使用大小为M的数组，保存N个键值対，其中M>N, 用数组的空位来解决碰撞冲突。称为开放地址散列表。

核心思想是：与其将内存用作链表，不如将他们作为散列表的空元素。

最简单的方法是线性探测法：发生碰撞时，直接检查散列表的下一个位置
+ 命中，该位置的键和被查找的键相同
+ 未命中，键为空（该位置没有键）
+ 继续查找，键不同，达到结尾时，折回开头

实现中，使用并行数组，一个保存键，一个保存值。

N / M 称为使用率，小于0, 需要保持在 1/8 ~ 1/2 之间。

据推论，使用率小于 1/2 时，预计次数在 1.5 ～ 2.5 之间。


### 3.4.4 调整数组大小

调整数组大小的时候，需要将所有的键重新插入新表中。

## 3.5 应用

几个具有代表性的例子：
+ 提取csv文件的字典程序和索引程序
+ 为一组文件构建逆向索引
+ 一个表示稀疏矩阵的数据类型。能够处理很大规模的问题

![符号表实现的渐进性能的总结](http://o9hjg7h8u.bkt.clouddn.com/3.5.1%E7%AC%A6%E5%8F%B7%E8%A1%A8%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%B8%90%E8%BF%9B%E6%80%A7%E8%83%BD%E7%9A%84%E6%80%BB%E7%BB%93.png)

### 3.5.2 集合的API

不需要处理值

返回类型 | SET(KEY) | 描述 
---|---|---
| Set() | 创建一个空的集合
void | add(Key key) | 将键key加入集合
void | delete(Key key) | 删除
boolean | contains(Key key) | key是否存在
boolean | isEmpty() | 集合是否为空
int | size() | 键的数量
string | toString() | 对象的字符串表示

其他操作：
+ 集合操作：union, intersection, complement
+ 有序性操作

典型应用：
+ dedup 将输入文件去除重复word后输出  
+ 白名单和黑名单 只输出（屏蔽）特定单词 BlackFilter WhiteFilter

### 3.5.3 字典类用例

+ 电话黄页：人名 - 电话号码
+ 字典：单词 - 含义
+ 账户信息：
+ 基因组学：密码子 - 氨基酸
+ 实验数据
+ 编译器：变量名 - 内存地址
+ 文件系统：文件名 - 文件内容
+ 互联网DNS：域名 - IP

### 3.5.4 索引类用例

一个键，和多个值相关联
+ 商业交易：客户帐号 - 所有交易
+ 网络搜索：关键字 - 一组网页
+ 电影和演员：电影名称 - 演员列表

LookupIndex 

反向索引：用值来查找键。也是一个键，对应一组值（可以用set表示）
+ 

### 3.5.5 稀疏向量 SparseVector

矩阵和向量的乘法。

PageRank 算法。

简化实现：N维矩阵 点乘 N维向量 

![稀疏矩阵的表示](http://o9hjg7h8u.bkt.clouddn.com/3.5.4%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E7%9A%84%E8%A1%A8%E7%A4%BA.png)

+ 数组实现的，时间复杂度是 N * N，因为需要进行 N*N 级别的乘法。
+ 以上原理实现的，仅和 N + 矩阵中非零元素数量 成正比。

可以用HashST表示每一行后边的数组对象。














  



