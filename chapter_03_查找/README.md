## 3.1 符号表

符号表：一张抽象的表格，我们会将信息存储在其中，然后按照指定的键来搜索并获取这些信息。有时称为字典，有时称为索引。

三种实现高效符号表的经典类型：二叉查找树，红黑树，散列表。

典型的符号表应用

应用|查找的目的|键|值
---|---|---|---
字典|找出单词的释义|单词|释义
图书索引|找出相关的页码|术语|一串页码
文件共享|找出歌曲的下载地址|歌曲名|url之类的
账户管理|处理交易|账户号码|交易详情
网络搜索|找出相关网页|关键字|网页名称
编译器|找出符号的类型和值|变量名|类型和值

### 3.1.1 API

符号表API

返回类型 | 方法名 | desc
---|---|---
 | ST()创建一张符号表 |
void | put(Key key, Value value) | 存入键值对
Value | get(Key key) | 获取键key对应的值
void | delete(Key key) | 删除键值对
boolean | contains(Key key) | 键key在表中是否有对应的值  get(key) != nul
boolean | isEmpty() | 表是否为空  size() == 0
int | size() | 键值对数量
Iterable<Key> | keys() | 所有键的集合

为了保持代码的一致、简洁和实用，以下是几个设计决策
+ 范型
+ 重复的键
  + 每个键只对应一个值
  + 新存入的键值対和表中已有的冲突时，新值会替换旧值
+ 空键null 键不能位null
+ 空值null 值不能有null
  + 键不存在时可以返回null
  + 导致可以使用 get() 的返回值判断键是否存在
  + 导致可以将值设置为 null(put) 来实现删除 
+ 删除操作
  + 延时删除 将键对应的值置为空，然后在某个时候删除所有值为空的键 put(key, null) 是一种实现
  + 即时删除 立刻从表中删除指定的键 delete(key) 是这种实现
+ 便捷方法 ：用已经实现的方法实现
+ 迭代 使用keys返回包含所有键的迭代器
+ 键的等价性 怎么判断键是否存在的等价

### 3.1.2 有序符号表

在典型应用中，键都是Comparable对象，许多符号表的实现，都利用Comparable带来的键的有序性，更好得实现put get方法。

以下是有序的泛型符号表API

返回值类型 | 方法名 | 说明
---|---|---
| ST() | 创建一张有序符号表
void | put(Key key, Value value) | 将键值対存入表中
Value | get(Key key) | 获取键key对应的值
void | delete(Key key) | 从表中删除键key
boolean | contains(Key key) | 表中是否有某个键
boolean | isEmpty() | 表是否为空
int | size() | 表中键值対数量
Key | min() | 最小的键
Key | max() | 最大的键
Key | floor(Key key) | 小于等于key的最大键
Key | ceiling(Key key) | 大于等于key的最小键
int | rank(Key key) | 小于key的键的数量
Key | select(int k) | 排名为k的键
void | deleteMin() | 删除最小的键 delete(min())
void | deleteMax() | 删除最大的键 delete(max())
int | size(Key lo, Key hi) | \[lo..hi\] 之间键的数量 
Iterable<Key> | keys(Key lo, Key hi) | \[lo..hi\]之间的所有键 
Iterable<Key> | keys() | 表中的所有键的集合，已排序 keys(min(), max())

#### 3.1.2.1 最大键和最小键

#### 3.1.2.2 向下取整和向上取整

floor ceiling

#### 3.1.2.3 排名和选择

+ 0 ~ size()-1 的所有i满足： i == rank(select(i))
+ 所有key都满足: key == select(rank(key))

挑战是，实现插入删除查找的同时，快速实现这两种操作。

#### 3.1.2.4 范围查找

size(), keys() 能够接受两个参数。

能够处理这类查询，是有序符号表在实践中被广泛应用的重要原因。

#### 3.1.2.5 例外情况

如果一个方法需要返回一个键但表中没有合适的键返回时，约定抛出一个异常。

符号表为空时，min(), max(), deleteMin(), deleteMax(), floor(), ceiling() 都会抛出异常。

k < 0, 或者 k >= size() 时，select(k) 也会抛出异常。

#### 3.1.2.6 便捷方法

#### 3.1.2.7 键的等价性

#### 3.1.2.8 成本模型

### 3.1.3 用例举例

#### 3.1.3.1 行为测试用例 

用一串字符串与各自对应的索引，来作为key value。

#### 3.1.3.2 性能测试用例

使用网上知名测试内容，进行单词统计。符号表运用共性：
+ 混合使用插入和查找的操作
+ 大量的不同键
+ 查找操作比插入操作多得多
+ 查找和插入操作并非随机

### 3.1.4 无序链表中的顺序查找

### 3.1.5 有序数组中的二分查找

+ 使用一対平行的数组，一个存储key，另一个存储value
+ 需要保证存储key数组有序
+ 实现核心是 rank() 方法，它返回小于给定键的元素的数量
+ get() put() 都借助与 rank()

put() 时间复杂度是对数级别，还是太慢了，依然无法支撑大型问题。

![3.1.9BinarySearchST操作成本.png](http://o9hjg7h8u.bkt.clouddn.com/3.1.9BinarySearchST%E6%93%8D%E4%BD%9C%E6%88%90%E6%9C%AC.png)

![符号表的各种实现的优缺点](http://o9hjg7h8u.bkt.clouddn.com/3.1.11%E7%AC%A6%E5%8F%B7%E8%A1%A8%E7%9A%84%E5%90%84%E7%A7%8D%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9.png)

## 3.2 二叉查找树 BST

能够将链表插入的灵活性，与有序数组查找的高效性相结合的符号表实现。

+ 结点指向的链接可以指向空或者其他结点
+ 每个结点只能有一个父节点指向自己（根结点没有父结点）
+ 每个结点只有左右两个链接，指向左子结点和右子节点
+ 每个结点都可以看作是一个二叉树

二叉树可以定义为一个空链接，或者一个有左右两个链接的结点，每个链接都指向一棵独立的二叉树。

![详解二叉树](http://o9hjg7h8u.bkt.clouddn.com/3.2.1%E8%AF%A6%E8%A7%A3%E4%BA%8C%E5%8F%89%E6%A0%91.png)

![详解二叉查找树](http://o9hjg7h8u.bkt.clouddn.com/3.2.2%E8%AF%A6%E8%A7%A3%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91.png)

### 3.2.1 基本实现

#### 3.2.1.1 数据表示

每个结点含有如下的结构：
+ 一个键
+ 一个值
+ 一条左链接：里边的键小于该结点
+ 一条右链接：里边的键大于该结点
+ 一个结点计数器：size(x) = size(x.left) + size(x.right) + 1

#### 3.2.1.2 查找

### 3.2.2 分析

二叉查找树和快速排序的相似性

查找命中平均需要的次数： 2lnN 约等于 1.39lgN. 比二分查找高 39%
 
插入操作和查找未命中平均所需比较次数 2lnN ~ 1.39lgN

![实验二叉树比较次数](http://o9hjg7h8u.bkt.clouddn.com/3.2.1%E5%AE%9E%E9%AA%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E6%AF%94%E8%BE%83%E6%AC%A1%E6%95%B0.png)

### 3.2.3 有序性相关的方法和删除操作

## 3.3 平衡查找树

保持二分查找树的平衡性。因为普通的二叉树在最坏情况下的性能很糟糕。

### 3.3.1 2-3查找树

一棵2-3查找树，或为一棵空树，或由以下结点组成：
+ 2-结点：含有1个键和两条链接
  + 左链接指向的2-3树中的键都小于该结点
  + 右链接指向的2-3树中的键都大于该结点
+ 2-结点：含有2个键和三条链接
  + 左链接指向的2-3树中的键都小于该结点
  + 中链接指向的2-3树中的键位于两个键中间
  + 右链接指向的2-3树中的键都大于该结点

指向空树的链接称为空链接。

![2-3查找树示意图](http://o9hjg7h8u.bkt.clouddn.com/3.3.1.2-3%E6%9F%A5%E6%89%BE%E6%A0%91%E7%A4%BA%E6%84%8F%E5%9B%BE.png)







  



